/**
 * This file is part of PLTB.
 * Copyright (C) 2015 Michael Hoff, Stefan Orf and Benedikt Riehm
 *
 * PLTB is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PLTB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PLTB.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <getopt.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <assert.h>
#include <unistd.h>

#define MPI_MASTER_WORKER 1

#include "pltb.h"
#include "models.h"
#include "debug.h"

#include "sequential.h"
#if MPI_MASTER_WORKER
	#include "masterworker.h"
#endif

#if MPI_MASTER_WORKER
	#define ERROR(fmt, ...) do { if (process_id == 0) fprintf(stderr, fmt, ##__VA_ARGS__); } while(0)
#else
	#define ERROR(fmt, ...) do { fprintf(stderr, fmt, ##__VA_ARGS__); } while(0)
#endif

static long parse_long(char *str)
{
	errno = 0;
	char *endptr;
	long val = strtol(str, &endptr, 0);

	if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))
			|| (errno != 0 && val == 0)
			|| *endptr != '\0') {
		return -1;
	}
	return val;
}

static int parse_int(char *str)
{
	long val = parse_long(str);
	if (val <= INT_MAX && val >= INT_MIN) {
		return (int)val;
	} else {
		return -1;
	}
}

int main (int argc, char **argv)
{
#if MPI_MASTER_WORKER
	int process_id;
	int n_processes;

	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &process_id);
	MPI_Comm_size(MPI_COMM_WORLD, &n_processes);
#endif

	static const unsigned NO_EXTRA_MODEL[] = {};
	const unsigned        EXTRA_GTR[] = { model_index_GTR };

	/* configuration */
	pltb_config_t config;

	/* pltb config */
	configure_attr_defaults(&config);
	config.extra_models   = (unsigned*)&NO_EXTRA_MODEL;
	config.n_extra_models = 0;
	config.base_freq_kind = EMPIRICAL;

	/* pltb target */
	char *datafile      = NULL;  /* illegal default => to be set */

	/* model space config */
	int  upper_bound    = 203;
	int  lower_bound    = 0;

	/* cli related configuration and variables */
	opterr = 0; /* avoid errors generated by getopt */
	int error = 0;
	int opt_index;
	int c;

	bool print_config   = false;
	bool print_progress = false;

	while (1) {
		static struct option long_options[] = {
			{"data",            required_argument, 0, 'f'},
			{"opt-base-freq",   no_argument,       0, 'b'},
			{"upper-bound",     required_argument, 0, 'u'},
			{"lower-bound",     required_argument, 0, 'l'},
			{"npthreads",       required_argument, 0, 'n'},
			{"npthreads-tree",  required_argument, 0, 's'},
			{"rseed",           required_argument, 0, 'r'},
			{"config",          no_argument,       0, 'c'},
			{"progress",        no_argument,       0, 'p'},
			{"with-gtr",        no_argument,       0, 'g'},
			{0,                 0,                 0, 0  }
		};

		c = getopt_long(argc, argv, "cpbgf:u:l:n:s:r:", long_options, &opt_index);

		if (c == -1) break;
		switch (c) {
			case 'b':
				config.base_freq_kind = OPTIMIZED;
				break;
			case 'f':
				if (access(optarg, R_OK) != -1) {
					datafile = optarg;
				} else {
					ERROR("Illegal dataset file: %s\n", optarg);
					error = 1;
				}
				break;
			case 'u':
				upper_bound = parse_int(optarg);
				if (upper_bound < 1 || upper_bound > 202) {
					ERROR("Illegal value for upper matrix index bound: %s\n", optarg);
					error = 1;
				}
				break;
			case 'l':
				lower_bound = parse_int(optarg);
				if (lower_bound < 0 || lower_bound > 202) {
					ERROR("Illegal value for lower matrix index bound: %s\n", optarg);
					error = 1;
				}
				break;
			case 'n':
				config.attr_model_eval.numberOfThreads = parse_int(optarg);
				if (config.attr_model_eval.numberOfThreads < 0) {
					ERROR("Negative value for number of pthreads: %s\n", optarg);
					error = 1;
				}
				break;
			case 's':
				config.attr_tree_search.numberOfThreads = parse_int(optarg);
				if (config.attr_tree_search.numberOfThreads < 0) {
					ERROR("Negative value for number of pthreads: %s\n", optarg);
					error = 1;
				}
				break;
			case 'r':
				config.attr_model_eval.randomNumberSeed = parse_long(optarg);
				config.attr_tree_search.randomNumberSeed = parse_long(optarg);
				break;
			case 'c':
				print_config = true;
				break;
			case 'p':
				print_progress = true;
				break;
			case 'g':
				config.n_extra_models = 1;
				config.extra_models = (unsigned*)&EXTRA_GTR;
				break;
			case 0:
				/* all long options return a value != 0 */
				assert(false);
				break;
			default:
				error = 1;
				break;
		}
	}

	while (optind < argc) {
		error = 1;
		ERROR("Not recognized option: %s\n", argv[optind++]);
		break;
	}

	if (!error && !datafile) {
		ERROR("Missing required file argument\n");
		error = 1;
	}

	if (!error) {
		if (lower_bound >= upper_bound) {
			ERROR("Upper bound greater then the lower bound.\n");
			error = 1;
		}
	}

	if(!error)
	{
#if MPI_MASTER_WORKER
		if (print_config && process_id == 0) {
#else
		if (print_config) {
#endif
			DBG("Configuration\n");
			DBG("\tDataset: %s\n", datafile);
			DBG("\tRandom number seeds: %#lx/%#lx\n", config.attr_model_eval.randomNumberSeed, config.attr_tree_search.randomNumberSeed);
			DBG("\tBase frequencies: ");
			switch (config.base_freq_kind) {
				case EMPIRICAL:
					DBG("Empirical");
					break;
				case OPTIMIZED:
					DBG("Optimized");
					break;
				case EQUAL:
					DBG("Equal - not implemented yet");
					break;
			}
			DBG("\n");
#if MPI_MASTER_WORKER
			DBG("\tNumber of processes: %d\n", n_processes);
#endif
			DBG("\tNumber of threads per process: %d\n", config.attr_model_eval.numberOfThreads);
			DBG("\tNumber of threads for tree search: %d\n", config.attr_tree_search.numberOfThreads);
#if MPI_MASTER_WORKER
			if (n_processes > 1) {
				DBG("\tImplementation: Parallel\n");
			} else {
				DBG("\tImplementation: Sequential\n");
			}
#endif
		}

		// configure model space
		model_space_t model_space;
		init_range_model_space(&model_space, (unsigned)lower_bound, (unsigned)upper_bound);
		// choose implementation
#if MPI_MASTER_WORKER
		if (n_processes > 1) {
			// mpi master worker
			error = run_master_worker(process_id, MPI_COMM_WORLD, datafile, &config, &model_space, print_progress);
		} else
#endif
		{
			// sequential
			error = run_sequential(datafile, &config, &model_space);
		}
		if (error) {
			ERROR("Execution ended with error code %d\n", error);
		}
		destroy_model_space(&model_space);
	} else {
		error = 1;
		ERROR("Usage: %s (-f|--data) datafile [-b|--opt-freq] [(-l|--lower-bound) incl_index] [(-u|--upper-bound) excl_index] [(-n|--npthreads) number] [(-s|--npthreads-tree) number] [(-r|--rseed) longvalue] [(-c|--config)] [(-p|--progress)] [(-g|--with-gtr)]\n", argv[0]);
	}
#if MPI_MASTER_WORKER
	MPI_Finalize();
#endif
	return error;
}
